Условия:
* Версии пакетов представляют собой натуральные числа
* Самые свежие зависимости — набор совместимых версий пакетов; такой, что любой другой набор совместимых версий имеет по крайней мере в одном из пакетов меньшую версию.
* Пакеты зависят от других пакетов, не допуская циклических зависимостей. Если некая версия пакета A — транзитивная зависимость некой версии пакета B, то никакая версия B не может являться транзитивной зависимостью никакой версии A.
* Зависимости возрастают монотонно. То есть при обновлении версии любого пакета его зависимости не могут понизить свои версии, только повысить либо не измениться.
* Список зависимостей у пакета постоянный, меняются только их версии
* Версии зависимостей каждого пакета фиксированы (нет диапазонов)
* Совместимые версии гарантированно существуют


Типы:

// описание зависимости
type PackageDependency = {
  packageName: string; // имя пакета
  version: number; // номер версии проекта
}

// описание версии
type PackageVersion = {
  version: number; // номер версии проекта
  dependencies?: PackageDependency[]; // список зависимостей проекта
}

// входные данные
type AllDependencies = {
  [packageName: string]: {
      versions: PackageVersion[], // все версии пакета
  };
}

// выходные данные 
type ResultDependencies = {
  [packageName: string]: number;
}

Шаблон решения:

function getLastCompatibleDependencies(data, packageA, packageB) {
  // ваше решение
}

exports.getLastCompatibleDependencies = getLastCompatibleDependencies;

необходимо реализовать функцию getLastCompatibleDependencies, которая находит максимально возможные версии пакетов packageA и packageB, не конфликтующих с версиями других пакетов